spring:
  application:
    name: store

  # =============================================================================================
  # DATABASE CONFIGURATION (H2 in-memory for development)
  # =============================================================================================
  datasource:
    url: jdbc:h2:mem:storedb
    driver-class-name: org.h2.Driver
    username: sa
    password:

  # JPA / Hibernate Configuration
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: update  # Auto-create/update tables (use 'validate' in production)
    show-sql: true      # Log SQL statements (disable in production)
    properties:
      hibernate:
        format_sql: true  # Pretty-print SQL (disable in production)

  # H2 Console (for debugging - disable in production)
  h2:
    console:
      enabled: true
      path: /h2-console

  # =============================================================================================
  # KAFKA CONFIGURATION
  # =============================================================================================
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}

    # Producer configurations
    producer:
      # Critical producer settings (high durability)
      critical:
        acks: all
        enable-idempotence: true
        retries: 2147483647  # Integer.MAX_VALUE
        delivery-timeout-ms: 120000
        request-timeout-ms: 30000
        max-in-flight-requests-per-connection: 5
        compression-type: snappy
        linger-ms: 10
        batch-size: 16384

      # Default producer settings (balanced)
      default:
        acks: 1
        compression-type: lz4

      # Fast producer settings (fire-and-forget)
      fast:
        acks: 0
        linger-ms: 50
        batch-size: 32768

    # Consumer configurations
    consumer:
      auto-offset-reset: latest

      # Critical consumer settings (manual commit)
      critical:
        enable-auto-commit: false
        max-poll-records: 1
        concurrency: 1

      # Default consumer settings (auto commit)
      default:
        enable-auto-commit: true
        concurrency: 3

      # Fast consumer settings (high throughput)
      fast:
        enable-auto-commit: true
        max-poll-records: 500
        concurrency: 8

    # Error handling
    error:
      retry:
        max-attempts: 5
        initial-interval-ms: 1000
        multiplier: 2
        max-interval-ms: 10000

    # Topics
    topics:
      payment-approved: ${KAFKA_TOPIC_PAYMENT_APPROVED:payment.approved.v1}
      payment-approved-dlq: ${KAFKA_TOPIC_PAYMENT_APPROVED_DLQ:payment.approved.v1.dlq}

server:
  port: 5050

# =============================================================================================
# DLQ REPROCESSOR CONFIGURATION
# =============================================================================================
# Controla se o DLQReprocessor deve estar ativo
#
# IMPORTANTE:
# - false (padrão): DLQReprocessor NÃO inicia - mensagens ficam na DLQ
# - true: DLQReprocessor ATIVO - republica mensagens automaticamente
#
# QUANDO HABILITAR (true):
# ✅ Após corrigir bug no PaymentApprovedConsumer e fazer deploy
# ✅ Após serviço externo voltar (ex: API de notificação)
# ✅ Para reprocessar mensagens após incidente resolvido
#
# QUANDO MANTER DESABILITADO (false):
# ❌ Enquanto o bug que causou a falha ainda existe (evita loop infinito!)
# ❌ Durante investigação de problemas
# ❌ Em ambientes de desenvolvimento/testes (use reprocessamento manual)
#
# =============================================================================================
dlq:
  reprocessor:
    enabled: false  # DEFAULT: false (segurança - evita loops acidentais)
