
---------------------------------------------------------------------------------------------------------------


 Layered Architecture â†’ Hexagonal Ã© uma migraÃ§Ã£o natural e progressiva. VocÃª estÃ¡ tomando a decisÃ£o certa!

  ---
  âœ… POR QUE ESSA ESCOLHA FAZ SENTIDO:

  Agora (Layered):

  - âœ… Estrutura clara: Application â†’ Domain â†’ Infrastructure
  - âœ… FÃ¡cil de entender (camadas bem definidas)
  - âœ… Melhora MUITO a organizaÃ§Ã£o atual
  - âœ… Prepara o terreno para Hexagonal

  Futuro (Hexagonal):

  - âœ… MigraÃ§Ã£o suave (sÃ³ reorganizar pacotes + adicionar ports)
  - âœ… Quando vocÃª entender melhor DDD
  - âœ… Quando o projeto crescer e precisar de mais isolamento

  ---
  ğŸ“¦ ESTRUTURA LAYERED PARA SEU PROJETO

  com.mvbr.store/
  â”‚
  â”œâ”€â”€ application/                           â† Camada de AplicaÃ§Ã£o
  â”‚   â”‚
  â”‚   â”œâ”€â”€ controller/                        â† REST API
  â”‚   â”‚   â””â”€â”€ PaymentController.java
  â”‚   â”‚
  â”‚   â”œâ”€â”€ dto/                               â† DTOs de entrada/saÃ­da
  â”‚   â”‚   â”œâ”€â”€ request/
  â”‚   â”‚   â”‚   â””â”€â”€ PaymentApprovedRequest.java
  â”‚   â”‚   â””â”€â”€ response/
  â”‚   â”‚       â””â”€â”€ PaymentResponse.java
  â”‚   â”‚
  â”‚   â””â”€â”€ service/                           â† Services (orquestraÃ§Ã£o)
  â”‚       â””â”€â”€ PaymentApplicationService.java
  â”‚
  â”œâ”€â”€ domain/                                â† Camada de DomÃ­nio
  â”‚   â”‚
  â”‚   â”œâ”€â”€ model/                             â† Entidades/Value Objects
  â”‚   â”‚   â”œâ”€â”€ Payment.java
  â”‚   â”‚   â””â”€â”€ PaymentStatus.java
  â”‚   â”‚
  â”‚   â”œâ”€â”€ event/                             â† Eventos de DOMÃNIO (internos)
  â”‚   â”‚   â””â”€â”€ PaymentApprovedDomainEvent.java
  â”‚   â”‚
  â”‚   â”œâ”€â”€ service/                           â† ServiÃ§os de domÃ­nio
  â”‚   â”‚   â””â”€â”€ PaymentDomainService.java
  â”‚   â”‚
  â”‚   â””â”€â”€ repository/                        â† Interfaces (contratos)
  â”‚       â””â”€â”€ PaymentRepository.java
  â”‚
  â””â”€â”€ infrastructure/                        â† Camada de Infraestrutura
      â”‚
      â”œâ”€â”€ config/                            â† ConfiguraÃ§Ãµes tÃ©cnicas
      â”‚   â”œâ”€â”€ kafka/
      â”‚   â”‚   â”œâ”€â”€ KafkaProducerConfig.java
      â”‚   â”‚   â””â”€â”€ KafkaConsumerConfig.java
      â”‚   â””â”€â”€ web/
      â”‚       â””â”€â”€ WebConfig.java
      â”‚
      â”œâ”€â”€ messaging/                         â† Kafka (toda mensageria)
      â”‚   â”‚
      â”‚   â”œâ”€â”€ event/                         â† Eventos do KAFKA (contratos externos)
      â”‚   â”‚   â””â”€â”€ PaymentApprovedEvent.java
      â”‚   â”‚
      â”‚   â”œâ”€â”€ producer/                      â† Produtores
      â”‚   â”‚   â””â”€â”€ PaymentApprovedProducer.java
      â”‚   â”‚
      â”‚   â”œâ”€â”€ consumer/                      â† Consumidores
      â”‚   â”‚   â””â”€â”€ PaymentApprovedConsumer.java
      â”‚   â”‚
      â”‚   â””â”€â”€ mapper/                        â† ConversÃ£o Domain â†” Kafka Event
      â”‚       â””â”€â”€ PaymentEventMapper.java
      â”‚
      â””â”€â”€ persistence/                       â† PersistÃªncia (quando tiver)
          â””â”€â”€ PaymentRepositoryImpl.java

  ---
  ğŸ”„ CAMINHO DE MIGRAÃ‡ÃƒO (Layered â†’ Hexagonal)

  Fase 1: Layered (AGORA)

  application/
    â””â”€â”€ service/
        â””â”€â”€ PaymentApplicationService.java  â† Orquestra tudo

  domain/
    â””â”€â”€ model/
        â””â”€â”€ Payment.java                    â† LÃ³gica de negÃ³cio

  infrastructure/
    â””â”€â”€ messaging/
        â””â”€â”€ producer/
            â””â”€â”€ PaymentApprovedProducer.java â† Envia para Kafka

  DependÃªncia: Application â†’ Domain â† Infrastructure

  ---
  Fase 2: Hexagonal (FUTURO)

  domain/
    â”œâ”€â”€ model/
    â”‚   â””â”€â”€ Payment.java
    â””â”€â”€ port/                              â† NOVO! Interfaces
        â””â”€â”€ PaymentEventPublisher.java    â† Contrato (sem implementaÃ§Ã£o)

  application/
    â””â”€â”€ usecase/
        â””â”€â”€ ApprovePaymentUseCase.java    â† Usa a interface (port)

  infrastructure/
    â””â”€â”€ adapter/
        â””â”€â”€ messaging/
            â””â”€â”€ KafkaPaymentEventPublisher.java â† Implementa a interface

  DependÃªncia: Domain â† Application â† Infrastructure (inversÃ£o!)

  ---
  ğŸ“‹ O QUE VAI MUDAR NA PRÃTICA

  Antes (estrutura atual flat):

  com.mvbr.store/
  â”œâ”€â”€ controller/PaymentController.java
  â”œâ”€â”€ dto/PaymentApprovedRequest.java
  â”œâ”€â”€ event/PaymentApprovedEvent.java      â† Confuso: domÃ­nio ou kafka?
  â”œâ”€â”€ model/Payment.java
  â”œâ”€â”€ producer/PaymentApprovedProducer.java
  â””â”€â”€ service/PaymentService.java

  Problema: Tudo misturado, difÃ­cil saber o que Ã© negÃ³cio vs tecnologia.

  ---
  Depois (Layered):

  application/
    â”œâ”€â”€ controller/PaymentController.java           â† Interface HTTP
    â”œâ”€â”€ dto/request/PaymentApprovedRequest.java     â† Contrato REST
    â””â”€â”€ service/PaymentApplicationService.java      â† Orquestra

  domain/
    â”œâ”€â”€ model/Payment.java                          â† LÃ³gica de negÃ³cio pura
    â””â”€â”€ event/PaymentApprovedDomainEvent.java       â† Evento interno (opcional)

  infrastructure/
    â”œâ”€â”€ config/kafka/KafkaProducerConfig.java       â† ConfiguraÃ§Ã£o tÃ©cnica
    â””â”€â”€ messaging/
        â”œâ”€â”€ event/PaymentApprovedEvent.java         â† Contrato Kafka (JSON)
        â”œâ”€â”€ producer/PaymentApprovedProducer.java   â† ImplementaÃ§Ã£o Kafka
        â””â”€â”€ mapper/PaymentEventMapper.java          â† ConversÃ£o Domain â†’ Kafka

  BenefÃ­cio:
  - âœ… Claro o que Ã© cada coisa
  - âœ… DomÃ­nio isolado (Payment nÃ£o sabe de Kafka)
  - âœ… FÃ¡cil de testar (camadas independentes)

  ---
  ğŸ¯ REGRAS DE DEPENDÃŠNCIA (CRUCIAL!)

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Application       â”‚  â† Pode depender de Domain
  â”‚   (controller,      â”‚  â† NÃƒO pode depender de Infrastructure
  â”‚    service, dto)    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â†“
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚   Domain            â”‚  â† NÃƒO depende de NADA!
  â”‚   (model, events,   â”‚  â† Zero imports de Spring, Kafka, etc
  â”‚    repository iface)â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â†‘
             â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Infrastructure     â”‚  â† Pode depender de Domain
  â”‚  (kafka, config,    â”‚  â† Pode depender de Application (com cuidado)
  â”‚   persistence)      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Na prÃ¡tica:

  âœ… PERMITIDO:

  // Application depende de Domain
  package com.mvbr.store.application.service;

  import com.mvbr.store.domain.model.Payment;  âœ…
  import com.mvbr.store.infrastructure.messaging.producer.PaymentApprovedProducer; âœ…

  âŒ PROIBIDO:

  // Domain NÃƒO pode depender de Infrastructure!
  package com.mvbr.store.domain.model;

  import org.springframework.kafka.core.KafkaTemplate;  âŒ NUNCA!
  import com.mvbr.store.infrastructure.config.KafkaProducerConfig; âŒ NUNCA!

  ---
  ğŸ”¥ DIFERENÃ‡AS IMPORTANTES

  1. Eventos: Domain vs Infrastructure

  | Tipo         | Onde fica                       | PropÃ³sito                              | Exemplo                    |
  |--------------|---------------------------------|----------------------------------------|----------------------------|
  | Domain Event | domain/event/                   | ComunicaÃ§Ã£o interna, regras de negÃ³cio | PaymentApprovedDomainEvent |
  | Kafka Event  | infrastructure/messaging/event/ | Contrato externo, JSON no tÃ³pico       | PaymentApprovedEvent       |

  DiferenÃ§a chave:
  // Domain Event (interno)
  package com.mvbr.store.domain.event;

  public record PaymentApprovedDomainEvent(Payment payment) {}
  // â†‘ ContÃ©m o objeto de domÃ­nio completo

  // Kafka Event (externo)
  package com.mvbr.store.infrastructure.messaging.event;

  public record PaymentApprovedEvent(
      String eventId,
      String paymentId,
      String userId,
      BigDecimal amount,
      String currency,
      String status,
      Long timestamp
  ) {}
  // â†‘ DTO serializado, versionado, contrato fixo

  ---
  2. Services: Application vs Domain

  | Tipo                | Onde fica            | Responsabilidade                            |
  |---------------------|----------------------|---------------------------------------------|
  | Application Service | application/service/ | Orquestra (chama domain + infra)            |
  | Domain Service      | domain/service/      | LÃ³gica de negÃ³cio complexa (cross-entities) |

  Exemplo:

  // Application Service (orquestra)
  package com.mvbr.store.application.service;

  @Service
  public class PaymentApplicationService {

      private final PaymentDomainService domainService;  // Se precisar
      private final PaymentApprovedProducer producer;

      public void approvePayment(PaymentApprovedRequest request) {
          // 1. Cria entidade de domÃ­nio
          Payment payment = new Payment(
              request.paymentId(),
              request.userId(),
              request.amount(),
              request.currency()
          );

          // 2. Executa lÃ³gica de domÃ­nio
          payment.markApproved();

          // 3. Mapeia para evento Kafka
          PaymentApprovedEvent kafkaEvent = PaymentEventMapper.toKafkaEvent(payment);

          // 4. Publica
          producer.producePaymentApproved(kafkaEvent);
      }
  }

  // Domain Service (lÃ³gica de negÃ³cio complexa)
  package com.mvbr.store.domain.service;

  public class PaymentDomainService {

      // Exemplo: lÃ³gica que envolve mÃºltiplas entidades
      public boolean canApprovePayment(Payment payment, Account account) {
          return payment.getAmount().compareTo(account.getBalance()) <= 0
              && account.isActive()
              && !payment.isExpired();
      }
  }

  ---
  ğŸš€ PRÃ“XIMOS PASSOS PRÃTICOS

  1. Criar a estrutura de pacotes

  mkdir -p src/main/java/com/mvbr/store/application/{controller,dto/{request,response},service}
  mkdir -p src/main/java/com/mvbr/store/domain/{model,event,service,repository}
  mkdir -p src/main/java/com/mvbr/store/infrastructure/{config/kafka,messaging/{event,producer,consumer,mapper},persistence}

  2. Mover arquivos gradualmente

  - controller/ â†’ application/controller/
  - dto/ â†’ application/dto/request/ e application/dto/response/
  - service/ â†’ application/service/
  - model/ â†’ domain/model/
  - producer/, consumer/, event/ â†’ infrastructure/messaging/
  - config/ â†’ infrastructure/config/kafka/

  3. Criar o Mapper (novo arquivo)

  // infrastructure/messaging/mapper/PaymentEventMapper.java
  package com.mvbr.store.infrastructure.messaging.mapper;

  public class PaymentEventMapper {

      public static PaymentApprovedEvent toKafkaEvent(Payment payment) {
          return new PaymentApprovedEvent(
              UUID.randomUUID().toString(),
              payment.getPaymentId(),
              payment.getUserId(),
              payment.getAmount(),
              payment.getCurrency(),
              payment.getStatus().name(),
              System.currentTimeMillis()
          );
      }
  }

  ---
  ğŸ“š COMPARAÃ‡ÃƒO: Layered vs Hexagonal (Futuro)

  | Aspecto              | Layered (Agora)              | Hexagonal (Futuro)               |
  |----------------------|------------------------------|----------------------------------|
  | Complexidade         | ğŸŸ¢ Baixa                     | ğŸŸ¡ MÃ©dia                         |
  | Testabilidade Domain | ğŸŸ¡ MÃ©dia (depende de Spring) | ğŸŸ¢ Alta (zero deps externas)     |
  | Isolamento           | ğŸŸ¡ Bom                       | ğŸŸ¢ Excelente                     |
  | Flexibilidade        | ğŸŸ¡ MÃ©dia                     | ğŸŸ¢ Alta (trocar tech facilmente) |
  | Curva aprendizado    | ğŸŸ¢ FÃ¡cil                     | ğŸŸ¡ MÃ©dia                         |

  ---
  ğŸ¯ RESUMO FINAL

  Sua decisÃ£o estÃ¡ perfeita porque:

  1. âœ… Layered resolve o problema atual (bagunÃ§a)
  2. âœ… Simples de entender e implementar
  3. âœ… Prepara para Hexagonal no futuro
  4. âœ… MigraÃ§Ã£o suave (sÃ³ adicionar ports/ depois)

  Quando migrar para Hexagonal?

  - â° Quando o projeto tiver 3+ bounded contexts (Payment, Order, Customer)
  - â° Quando precisar trocar tecnologias com frequÃªncia
  - â° Quando vocÃª estiver confortÃ¡vel com DDD



---------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------



---------------------------------------------------------------------------------------------------------------

